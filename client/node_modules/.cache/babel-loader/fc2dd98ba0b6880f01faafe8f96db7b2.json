{"ast":null,"code":"var __rest = this && this.__rest || function (s, e) {\n  var t = {};\n\n  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n};\n\nimport React, { useCallback, useEffect, useMemo, useRef, useState } from \"react\";\nimport BezierEasing from \"bezier-easing\"; // @ts-ignore\n\nimport ScrollManager from \"window-scroll-manager\"; // ------------ Constants\n// Regex that checks for numbers in string\n// formatted as \"{number}{unit}\" where unit is \"px\", \"vh\", \"%\" or none\n\nconst START_END_DURATION_REGEX = /^-?\\d+(\\.\\d+)?(px|vh|%)?$/;\nconst DEFAULT_UNIT = \"px\";\nconst DEFAULT_ANGLE_UNIT = \"deg\";\nconst ANGLE_PROPERTIES = [\"rotate\", \"rotateX\", \"rotateY\", \"rotateZ\", \"skew\", \"skewX\", \"skewY\", \"skewZ\", \"hueRotate\"];\nconst EASINGS = {\n  ease: [0.25, 0.1, 0.25, 1.0],\n  easeIn: [0.42, 0.0, 1.0, 1.0],\n  easeOut: [0.0, 0.0, 0.58, 1.0],\n  easeInOut: [0.42, 0.0, 0.58, 1.0],\n  easeInSine: [0.47, 0, 0.745, 0.715],\n  easeOutSine: [0.39, 0.575, 0.565, 1],\n  easeInOutSine: [0.445, 0.05, 0.55, 0.95],\n  easeInQuad: [0.55, 0.085, 0.68, 0.53],\n  easeOutQuad: [0.25, 0.46, 0.45, 0.94],\n  easeInOutQuad: [0.455, 0.03, 0.515, 0.955],\n  easeInCubic: [0.55, 0.055, 0.675, 0.19],\n  easeOutCubic: [0.215, 0.61, 0.355, 1],\n  easeInOutCubic: [0.645, 0.045, 0.355, 1],\n  easeInQuart: [0.895, 0.03, 0.685, 0.22],\n  easeOutQuart: [0.165, 0.84, 0.44, 1],\n  easeInOutQuart: [0.77, 0, 0.175, 1],\n  easeInQuint: [0.755, 0.05, 0.855, 0.06],\n  easeOutQuint: [0.23, 1, 0.32, 1],\n  easeInOutQuint: [0.86, 0, 0.07, 1],\n  easeInExpo: [0.95, 0.05, 0.795, 0.035],\n  easeOutExpo: [0.19, 1, 0.22, 1],\n  easeInOutExpo: [1, 0, 0, 1],\n  easeInCirc: [0.6, 0.04, 0.98, 0.335],\n  easeOutCirc: [0.075, 0.82, 0.165, 1],\n  easeInOutCirc: [0.785, 0.135, 0.15, 0.86]\n}; // Color regex\n// 0 - 199 | 200 - 249 | 250 - 255\n\nconst REGEX_0_255 = \"(1?[0-9]?[0-9]|2[0-4][0-9]|25[0-5])\"; // 0.0 - 1.9999...\n\nconst REGEX_0_1 = \"([01](\\\\.\\\\d+)?)\"; // 00 - FF\n\nconst REGEX_TWO_HEX_DIGITS = \"([a-f\\\\d]{2})\";\nconst HEX_REGEX = new RegExp(`^#${REGEX_TWO_HEX_DIGITS}${REGEX_TWO_HEX_DIGITS}${REGEX_TWO_HEX_DIGITS}$`, \"i\");\nconst RGB_REGEX = new RegExp(`^rgb\\\\(${REGEX_0_255},${REGEX_0_255},${REGEX_0_255}\\\\)$`, \"i\");\nconst RGBA_REGEX = new RegExp(`^rgba\\\\(${REGEX_0_255},${REGEX_0_255},${REGEX_0_255},${REGEX_0_1}\\\\)$`, \"i\");\nconst SCROLL_OFFSET = 50;\nconst RESIZE_DEBOUNCE_TIMEOUT = 150; // CSS transform map\n\nconst TRANSFORM_MAP = {\n  rotate: function (value) {\n    let unit = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : DEFAULT_ANGLE_UNIT;\n    return `rotate(${value}${unit})`;\n  },\n  rotateX: function (value) {\n    let unit = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : DEFAULT_ANGLE_UNIT;\n    return `rotateX(${value}${unit})`;\n  },\n  rotateY: function (value) {\n    let unit = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : DEFAULT_ANGLE_UNIT;\n    return `rotateY(${value}${unit})`;\n  },\n  rotateZ: function (value) {\n    let unit = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : DEFAULT_ANGLE_UNIT;\n    return `rotateZ(${value}${unit})`;\n  },\n  scale: value => `scale(${value})`,\n  scaleX: value => `scaleX(${value})`,\n  scaleY: value => `scaleY(${value})`,\n  scaleZ: value => `scaleZ(${value})`,\n  skew: function (value) {\n    let unit = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : DEFAULT_UNIT;\n    return `skew(${value}${unit})`;\n  },\n  skewX: function (value) {\n    let unit = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : DEFAULT_UNIT;\n    return `skewX(${value}${unit})`;\n  },\n  skewY: function (value) {\n    let unit = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : DEFAULT_UNIT;\n    return `skewY(${value}${unit})`;\n  },\n  skewZ: function (value) {\n    let unit = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : DEFAULT_UNIT;\n    return `skewZ(${value}${unit})`;\n  },\n  translateX: function (value) {\n    let unit = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : DEFAULT_UNIT;\n    return `translateX(${value}${unit})`;\n  },\n  translateY: function (value) {\n    let unit = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : DEFAULT_UNIT;\n    return `translateY(${value}${unit})`;\n  },\n  translateZ: function (value) {\n    let unit = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : DEFAULT_UNIT;\n    return `translateZ(${value}${unit})`;\n  }\n}; // Order of CSS transforms matters\n\nconst ORDER_OF_TRANSFORMS = [\"translateX\", \"translateY\", \"translateZ\", \"skew\", \"skewX\", \"skewY\", \"skewZ\", \"rotate\", \"rotateX\", \"rotateY\", \"rotateZ\", \"scale\", \"scaleX\", \"scaleY\", \"scaleZ\"]; // CSS properties that use color values\n\nconst COLOR_PROPERTIES = [\"backgroundColor\", \"borderBottomColor\", \"borderColor\", \"borderLeftColor\", \"borderRightColor\", \"borderTopColor\", \"color\", \"fill\", \"stroke\"]; // CSS filter map\n// blur()\n// brightness()\n// contrast()\n// grayscale()\n// hue-rotate()\n// invert()\n// opacity() // use opacityFilter\n// saturate()\n// sepia()\n// Not supported\n// drop-shadow()\n// url()\n\nconst FILTER_MAP = {\n  blur: function (value) {\n    let unit = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : DEFAULT_UNIT;\n    return `blur(${value}${unit})`;\n  },\n  brightness: value => `brightness(${value})`,\n  contrast: value => `contrast(${value})`,\n  grayscale: value => `grayscale(${value})`,\n  hueRotate: function (value) {\n    let unit = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : DEFAULT_ANGLE_UNIT;\n    return `hue-rotate(${value}${unit})`;\n  },\n  invert: value => `invert(${value})`,\n  opacityFilter: value => `opacity(${value})`,\n  saturate: value => `saturate(${value})`,\n  sepia: value => `sepia(${value})`\n};\nconst FILTER_PROPERTIES = [\"blur\", \"brightness\", \"contrast\", \"grayscale\", \"hueRotate\", \"invert\", \"opacityFilter\", \"saturate\", \"sepia\"]; // ------------ Helpers\n// Get element's top offset\n\nfunction getElementTop(el) {\n  let top = 0;\n  let element = el;\n\n  do {\n    top += element.offsetTop || 0;\n    element = element.offsetParent;\n  } while (element);\n\n  return top;\n} // Returns CSS unit\n\n\nfunction getUnit(property, unit) {\n  let propertyUnit = unit || DEFAULT_UNIT;\n\n  if (ANGLE_PROPERTIES.indexOf(property) >= 0) {\n    propertyUnit = unit || DEFAULT_ANGLE_UNIT;\n  }\n\n  return propertyUnit;\n} // Takes string value (in px/vh/%) and returns number\n\n\nfunction getValueInPx(value, maxScroll) {\n  var _a;\n\n  const floatValue = parseFloat(value);\n  const unit = ((_a = value.match(START_END_DURATION_REGEX)) === null || _a === void 0 ? void 0 : _a[2]) || null;\n  const vh = window.innerHeight / 100;\n  let valueInPx;\n\n  switch (unit) {\n    case \"vh\":\n      valueInPx = vh * floatValue;\n      break;\n\n    case \"%\":\n      valueInPx = maxScroll * floatValue / 100;\n      break;\n\n    default:\n      valueInPx = floatValue;\n  }\n\n  return valueInPx;\n} // Takes start/end/duration props\n// and return number (in pixels) based on prop type (number, string, dom element)\n\n\nfunction convertPropToPixels(propName, propValue, maxScroll) {\n  let offset = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n  let propValueInPx = propValue;\n  const isElement = propValue instanceof HTMLElement;\n  const keyCodes = {\n    ZERO: 48,\n    NINE: 57\n  };\n\n  if (typeof propValue === \"number\") {\n    propValueInPx = propValue;\n  } else if (START_END_DURATION_REGEX.test(propValue)) {\n    propValueInPx = getValueInPx(propValue, maxScroll);\n  } else if (isElement || typeof propValue === \"string\" && (propValue.charCodeAt(0) < keyCodes.ZERO || propValue.charCodeAt(0) > keyCodes.NINE)) {\n    const element = isElement ? propValue : document.querySelector(propValue);\n\n    if (!element) {\n      console.warn(`Plx, ERROR: ${propName} selector matches no elements: \"${propValue}\"`);\n      return null;\n    }\n\n    if (propName === \"start\" || propName === \"end\") {\n      // START or END\n      // Element enters the viewport\n      propValueInPx = getElementTop(element) - window.innerHeight;\n    } else if (propName === \"duration\") {\n      // DURATION\n      // Height of the element\n      propValueInPx = element.offsetHeight;\n    }\n  } else {\n    console.warn(`Plx, ERROR: \"${propValue}\" is not a valid ${propName} value, check documentation`);\n    return null;\n  } // Transform offset to px\n\n\n  let offsetInPx = 0;\n\n  if (typeof offset === \"number\") {\n    offsetInPx = offset;\n  } else if (START_END_DURATION_REGEX.test(offset)) {\n    offsetInPx = getValueInPx(offset, maxScroll);\n  } // Add offset\n\n\n  propValueInPx += offsetInPx;\n\n  if (propValueInPx < 0) {\n    propValueInPx = 0;\n  }\n\n  return propValueInPx;\n} // Converts color in hex format into object { r, g, b, a }\n\n\nfunction hexToObject(hex) {\n  // Convert #abc to #aabbcc\n  const color = hex.length === 4 ? `#${hex[1]}${hex[1]}${hex[2]}${hex[2]}${hex[3]}${hex[3]}` : hex;\n  const result = HEX_REGEX.exec(color); // Safety check, if color is in the wrong format\n\n  if (!result) {\n    console.warn(`Plx, ERROR: hex color is not in the right format: \"${hex}\"`);\n    return null;\n  } // All color functions are returning { r, g, b, a } object\n\n\n  return {\n    r: parseInt(result[1], 16),\n    g: parseInt(result[2], 16),\n    b: parseInt(result[3], 16),\n    a: 1\n  };\n} // Converts color in rgb format into object { r, g, b, a }\n\n\nfunction rgbToObject(rgb) {\n  const isRgba = rgb.toLowerCase().indexOf(\"rgba\") === 0;\n  const color = rgb.replace(/ /g, \"\");\n  const result = isRgba ? RGBA_REGEX.exec(color) : RGB_REGEX.exec(color); // Safety check, if color is in the wrong format\n\n  if (!result) {\n    console.warn(`Plx, ERROR: rgb or rgba color is not in the right format: \"${rgb}\"`);\n    return null;\n  } // All color functions are returning { r, g, b, a } object\n\n\n  return {\n    r: parseInt(result[1], 10),\n    g: parseInt(result[2], 10),\n    b: parseInt(result[3], 10),\n    a: isRgba ? parseFloat(result[4]) : 1\n  };\n} // Calculates the current value for parallax-ing property\n\n\nfunction parallax(scrollPosition, start, duration, startValue, endValue, easing) {\n  // Safety check, if \"startValue\" is in the wrong format\n  if (typeof startValue !== \"number\") {\n    console.warn(`Plx, ERROR: startValue is not a number (type: \"${typeof endValue}\", value: \"${endValue}\")`);\n    return 0;\n  } // Safety check, if \"endValue\" is in the wrong format\n\n\n  if (typeof endValue !== \"number\") {\n    console.warn(`Plx, ERROR: endValue is not a number (type: \"${typeof endValue}\", value: \"${endValue}\")`);\n    return 0;\n  } // Safety check, if \"duration\" is in the wrong format\n\n\n  if (typeof duration !== \"number\" || duration === 0) {\n    console.warn(`Plx, ERROR: duration is zero or not a number (type: \"${typeof duration}\", value: \"${duration}\")`);\n    return 0;\n  }\n\n  let min = startValue;\n  let max = endValue;\n  const invert = startValue > endValue;\n\n  if (invert) {\n    min = endValue;\n    max = startValue;\n  }\n\n  let percentage = (scrollPosition - start) / duration;\n\n  if (percentage > 1) {\n    percentage = 1;\n  } else if (percentage < 0) {\n    percentage = 0;\n  } // Apply easing\n\n\n  if (easing) {\n    if (Array.isArray(easing)) {\n      percentage = BezierEasing(easing[0], easing[1], easing[2], easing[3])(percentage);\n    } else if (typeof easing === \"string\" && EASINGS[easing]) {\n      percentage = BezierEasing(EASINGS[easing][0], EASINGS[easing][1], EASINGS[easing][2], EASINGS[easing][3])(percentage);\n    } else if (typeof easing === \"function\") {\n      percentage = easing(percentage);\n    }\n  }\n\n  let value = percentage * (max - min);\n\n  if (invert) {\n    value = max - value;\n  } else {\n    value += min;\n  } // Rounding to 4 decimals (.toFixed(4) returns a string)\n\n\n  return Math.floor(value * 10000) / 10000;\n} // Calculates current value for color parallax\n\n\nfunction colorParallax(scrollPosition, start, duration, startValue, endValue, easing) {\n  let startObject = null;\n  let endObject = null;\n\n  if (typeof startValue === \"string\") {\n    if (startValue[0].toLowerCase() === \"r\") {\n      startObject = rgbToObject(startValue);\n    } else {\n      startObject = hexToObject(startValue);\n    }\n  }\n\n  if (typeof endValue === \"string\") {\n    if (endValue[0].toLowerCase() === \"r\") {\n      endObject = rgbToObject(endValue);\n    } else {\n      endObject = hexToObject(endValue);\n    }\n  }\n\n  if (startObject && endObject) {\n    const r = parallax(scrollPosition, start, duration, startObject.r, endObject.r, easing);\n    const g = parallax(scrollPosition, start, duration, startObject.g, endObject.g, easing);\n    const b = parallax(scrollPosition, start, duration, startObject.b, endObject.b, easing);\n    const a = parallax(scrollPosition, start, duration, startObject.a, endObject.a, easing);\n    return `rgba(${Math.round(r)}, ${Math.round(g)}, ${Math.round(b)}, ${a})`;\n  }\n\n  return \"\";\n} // Applies property parallax to the style object\n\n\nfunction applyPropertyToStyle(scrollPosition, propertyData, startPosition, duration, style, transforms, filters, easing) {\n  const {\n    startValue,\n    endValue,\n    property,\n    unit\n  } = propertyData; // If property is one of the color properties\n  // Use it's parallax method\n\n  const isColor = COLOR_PROPERTIES.indexOf(property) > -1;\n  const parallaxMethod = isColor ? colorParallax : parallax; // Get new CSS value\n\n  const value = parallaxMethod(scrollPosition, startPosition, duration, startValue, endValue, easing); // Get transform function\n\n  const transformMethod = TRANSFORM_MAP[property];\n  const filterMethod = FILTER_MAP[property];\n  const newStyle = style;\n\n  if (transformMethod) {\n    // Get CSS unit\n    const propertyUnit = getUnit(property, unit); // Transforms, apply value to transform function\n\n    transforms[property] = transformMethod(value, propertyUnit);\n  } else if (filterMethod) {\n    // Get CSS unit\n    const propertyUnit = getUnit(property, unit); // Filters, apply value to filter function\n\n    filters[property] = filterMethod(value, propertyUnit);\n  } else {\n    // All other properties\n    newStyle[property] = value; // Add unit if it is passed\n\n    if (unit) {\n      newStyle[property] += unit;\n    }\n  }\n} // Returns CSS classes based on animation state\n\n\nfunction getClasses(lastSegmentScrolledBy, isInSegment, parallaxData) {\n  let cssClasses = \"\";\n\n  if (lastSegmentScrolledBy === null) {\n    cssClasses = \"Plx--above\";\n  } else if (lastSegmentScrolledBy === parallaxData.length - 1 && !isInSegment) {\n    cssClasses = \"Plx--below\";\n  } else if (lastSegmentScrolledBy !== null && isInSegment) {\n    const segmentName = parallaxData[lastSegmentScrolledBy].name || lastSegmentScrolledBy;\n    cssClasses = `Plx--active Plx--in Plx--in-${segmentName}`;\n  } else if (lastSegmentScrolledBy !== null && !isInSegment) {\n    const segmentName = parallaxData[lastSegmentScrolledBy].name || lastSegmentScrolledBy;\n    const nextSegmentName = parallaxData[lastSegmentScrolledBy + 1].name || lastSegmentScrolledBy + 1;\n    cssClasses = `Plx--active Plx--between Plx--between-${segmentName}-and-${nextSegmentName}`;\n  }\n\n  return cssClasses;\n} // Checks if class contains 'active'\n\n\nfunction checkIsActive(classes) {\n  return classes.indexOf(\"Plx--active\") > -1;\n} // Main update function\n// Returns new state object based on props and scroll position\n\n\nfunction updateDOM(scrollPosition, props, showElement, propsUsedInParallax, plxStyleRef, plxStateClassesRef, elementRef) {\n  const {\n    animateWhenNotInViewport,\n    disabled,\n    freeze,\n    parallaxData,\n    className,\n    onPlxEnd,\n    onPlxStart,\n    style\n  } = props;\n  const plxStyle = plxStyleRef.current;\n  const plxStateClasses = plxStateClassesRef.current;\n  const element = elementRef.current; // Do nothing if animation is disabled, frozen\n  // or if element is not rendered yet\n\n  if (freeze && showElement || !element || disabled) {\n    return;\n  } // Check if element is in viewport\n  // Small offset is added to prevent page jumping\n\n\n  if (!animateWhenNotInViewport) {\n    const rect = element.getBoundingClientRect();\n    const isTopAboveBottomEdge = rect.top < window.innerHeight + SCROLL_OFFSET;\n    const isBottomBelowTopEdge = rect.top + rect.height > -SCROLL_OFFSET;\n\n    if (!isTopAboveBottomEdge || !isBottomBelowTopEdge) {\n      return;\n    }\n  } // Style to be applied to our element\n\n\n  let newStyle = {};\n  const transforms = {};\n  const filters = {};\n  const appliedProperties = [];\n  const segments = [];\n  let isInSegment = false;\n  let lastSegmentScrolledBy = null;\n  const bodyHeight = document.documentElement.scrollHeight || document.body.scrollHeight;\n  const maxScroll = bodyHeight - window.innerHeight;\n\n  for (let i = 0; i < parallaxData.length; i++) {\n    const {\n      duration,\n      easing,\n      endOffset,\n      properties,\n      startOffset\n    } = parallaxData[i];\n    const start = parallaxData[i].start === \"self\" ? element : parallaxData[i].start;\n    const end = parallaxData[i].end === \"self\" ? element : parallaxData[i].end;\n    const startInPx = convertPropToPixels(\"start\", start, maxScroll, startOffset);\n    let durationInPx;\n    let endInPx; // End has higher priority than duration\n\n    if (typeof end !== \"undefined\") {\n      endInPx = convertPropToPixels(\"end\", end, maxScroll, endOffset);\n      durationInPx = endInPx - startInPx;\n    } else {\n      durationInPx = convertPropToPixels(\"duration\", duration, maxScroll);\n      endInPx = startInPx + durationInPx;\n    } // If segment is below scroll position skip it\n\n\n    if (scrollPosition < startInPx) {\n      break;\n    }\n\n    const isScrolledByStart = scrollPosition >= startInPx;\n\n    if (isScrolledByStart) {\n      lastSegmentScrolledBy = i;\n    } // If active segment exists, apply his properties\n\n\n    if (scrollPosition >= startInPx && scrollPosition <= endInPx) {\n      isInSegment = true;\n      properties.forEach(propertyData => {\n        const {\n          property\n        } = propertyData; // Save which properties are applied to the active segment\n        // So they are not re-applied for other segments\n\n        appliedProperties.push(property); // Apply property style\n\n        applyPropertyToStyle(scrollPosition, propertyData, startInPx, durationInPx, newStyle, transforms, filters, easing);\n      });\n    } else {\n      // Push non active segments above the scroll position to separate array\n      // This way \"durationInPx\" and \"startInPx\" are not calculated again\n      // and segments below scroll position are skipped in the next step\n      segments.push({\n        easing,\n        durationInPx,\n        properties,\n        startInPx\n      });\n    }\n  } // These are only segments that are completely above scroll position\n\n\n  segments.forEach(data => {\n    const {\n      easing,\n      durationInPx,\n      properties,\n      startInPx\n    } = data;\n    properties.forEach(propertyData => {\n      const {\n        property\n      } = propertyData; // Skip property that was changed for active segment\n\n      if (appliedProperties.indexOf(property) > -1) {\n        return;\n      } // These styles that are the ones changed by segments\n      // that are above active segment\n\n\n      applyPropertyToStyle(scrollPosition, propertyData, startInPx, durationInPx, newStyle, transforms, filters, easing);\n    });\n  }); // Sort transforms by ORDER_OF_TRANSFORMS\n  // as order of CSS transforms matters\n\n  const transformsOrdered = [];\n  ORDER_OF_TRANSFORMS.forEach(transformKey => {\n    if (transforms[transformKey]) {\n      transformsOrdered.push(transforms[transformKey]);\n    }\n  }); // Concat transforms and add webkit prefix\n\n  newStyle.transform = transformsOrdered.join(\" \");\n  newStyle.webkitTransform = newStyle.transform;\n  const filtersArray = [];\n  FILTER_PROPERTIES.forEach(filterKey => {\n    if (filters[filterKey]) {\n      filtersArray.push(filters[filterKey]);\n    }\n  }); // Concat filters and add webkit prefix\n\n  newStyle.filter = filtersArray.join(\" \");\n  newStyle.webkitFilter = newStyle.filter; // \"Stupid\" check if style should be updated\n\n  if (JSON.stringify(plxStyle) !== JSON.stringify(newStyle)) {\n    // Set styles\n    requestAnimationFrame(() => {\n      // Add user styles\n      for (const property in style) {\n        // @ts-ignore\n        element.style[property] = style[property];\n      } // Add parallax styles\n\n\n      propsUsedInParallax.forEach(property => {\n        // @ts-ignore\n        element.style[property] = typeof newStyle[property] === \"undefined\" ? \"\" : newStyle[property];\n      });\n    });\n    plxStyleRef.current = newStyle;\n  } // Adding state classes\n\n\n  const newPlxStateClasses = getClasses(lastSegmentScrolledBy, isInSegment, parallaxData);\n\n  if (newPlxStateClasses !== plxStateClasses) {\n    const newClassName = `${className} Plx ${newPlxStateClasses}`;\n\n    if (newClassName !== element.className) {\n      const wasActive = checkIsActive(element.className);\n      const isActive = checkIsActive(newClassName);\n      element.className = newClassName; // Callbacks\n\n      if (!wasActive && isActive) {\n        onPlxStart === null || onPlxStart === void 0 ? void 0 : onPlxStart();\n      } else if (wasActive && !isActive) {\n        onPlxEnd === null || onPlxEnd === void 0 ? void 0 : onPlxEnd();\n      }\n    } // Cache plx classes\n\n\n    plxStateClassesRef.current = newPlxStateClasses;\n  }\n}\n\nconst Plx = props => {\n  const {\n    animateWhenNotInViewport = false,\n    children,\n    className = \"\",\n    disabled = false,\n    freeze = false,\n    parallaxData,\n    style = {},\n    onPlxStart,\n    onPlxEnd\n  } = props,\n        divProps = __rest(props, [\"animateWhenNotInViewport\", \"children\", \"className\", \"disabled\", \"freeze\", \"parallaxData\", \"style\", \"onPlxStart\", \"onPlxEnd\"]);\n\n  const scrollManager = useRef();\n  const resizeTimeout = useRef();\n  const element = useRef(null);\n  const plxStyle = useRef({});\n  const plxStyleClasses = useRef(\"\");\n  const [showElement, setShowElement] = useState(false); // Get properties that are used in a parallax effect\n\n  const propsUsedInParallax = useMemo(() => {\n    const properties = [];\n    parallaxData.forEach(segment => {\n      segment.properties.forEach(_ref => {\n        let {\n          property\n        } = _ref;\n        const transformMethod = TRANSFORM_MAP[property];\n        const filterMethod = FILTER_MAP[property];\n\n        if (transformMethod) {\n          if (!properties.includes(\"transform\")) {\n            properties.push(\"transform\", \"webkitTransform\");\n          }\n        } else if (filterMethod) {\n          if (!properties.includes(\"filter\")) {\n            properties.push(\"filter\", \"webkitFilter\");\n          }\n        } else {\n          if (!properties.includes(property)) {\n            properties.push(property);\n          }\n        }\n      });\n    });\n    return properties;\n  }, [parallaxData]); // Set will-change property\n\n  useEffect(() => {\n    if (element.current) {\n      element.current.style.willChange = propsUsedInParallax.map(str => {\n        return str.replace(/[A-Z]/g, letter => `-${letter.toLowerCase()}`).replace(\"webkit\", \"-webkit\");\n      }).join(\",\");\n    }\n  }, [element, propsUsedInParallax]);\n  const update = useCallback(function () {\n    let scrollPosition = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n    const currentScrollPosition = scrollPosition === null ? scrollManager.current.getScrollPosition().scrollPositionY : scrollPosition;\n    updateDOM(currentScrollPosition, props, showElement, propsUsedInParallax, plxStyle, plxStyleClasses, element);\n  }, [props]); // Window resize\n\n  const handleResize = useCallback(() => {\n    clearTimeout(resizeTimeout.current);\n    resizeTimeout.current = setTimeout(() => {\n      update();\n    }, RESIZE_DEBOUNCE_TIMEOUT);\n  }, [props]);\n  useEffect(() => {\n    if (scrollManager.current) {\n      if (disabled) {\n        // When disabled leave only user styles\n        propsUsedInParallax.forEach(property => {\n          if (element.current) {\n            // @ts-ignore\n            element.current.style[property] = \"\";\n          }\n        });\n      } else {\n        update();\n      }\n    }\n  }, [disabled]); // Window scroll\n\n  const handleScrollChange = useCallback(e => {\n    update(e.detail.scrollPositionY);\n  }, [props]);\n  useEffect(() => {\n    // Get scroll manager singleton\n    scrollManager.current = new ScrollManager(); // Add listeners\n\n    window.addEventListener(\"window-scroll\", handleScrollChange);\n    window.addEventListener(\"resize\", handleResize);\n    update();\n    setShowElement(true);\n    return () => {\n      clearTimeout(resizeTimeout.current);\n      window.removeEventListener(\"window-scroll\", handleScrollChange);\n      window.removeEventListener(\"resize\", handleResize);\n      scrollManager.current.removeListener();\n    };\n  }, [props]); // Update DOM on props change\n\n  useEffect(() => {\n    update();\n  }, []);\n  let elementStyle = style;\n\n  if (!disabled) {\n    elementStyle = Object.assign(Object.assign({}, style), {\n      // Hide element before until it is rendered\n      // This prevents jumps if page is scrolled and then refreshed\n      visibility: showElement ? undefined : \"hidden\"\n    });\n  }\n\n  return React.createElement(\"div\", Object.assign({}, divProps, {\n    className: `${className} Plx`,\n    style: elementStyle,\n    ref: element\n  }), children);\n};\n\nexport default Plx;","map":{"version":3,"sources":["/Users/Jason/Desktop/Folders/milliondollar-web-app/client/node_modules/react-plx/dist/esm/index.js"],"names":["__rest","s","e","t","p","Object","prototype","hasOwnProperty","call","indexOf","getOwnPropertySymbols","i","length","propertyIsEnumerable","React","useCallback","useEffect","useMemo","useRef","useState","BezierEasing","ScrollManager","START_END_DURATION_REGEX","DEFAULT_UNIT","DEFAULT_ANGLE_UNIT","ANGLE_PROPERTIES","EASINGS","ease","easeIn","easeOut","easeInOut","easeInSine","easeOutSine","easeInOutSine","easeInQuad","easeOutQuad","easeInOutQuad","easeInCubic","easeOutCubic","easeInOutCubic","easeInQuart","easeOutQuart","easeInOutQuart","easeInQuint","easeOutQuint","easeInOutQuint","easeInExpo","easeOutExpo","easeInOutExpo","easeInCirc","easeOutCirc","easeInOutCirc","REGEX_0_255","REGEX_0_1","REGEX_TWO_HEX_DIGITS","HEX_REGEX","RegExp","RGB_REGEX","RGBA_REGEX","SCROLL_OFFSET","RESIZE_DEBOUNCE_TIMEOUT","TRANSFORM_MAP","rotate","value","unit","rotateX","rotateY","rotateZ","scale","scaleX","scaleY","scaleZ","skew","skewX","skewY","skewZ","translateX","translateY","translateZ","ORDER_OF_TRANSFORMS","COLOR_PROPERTIES","FILTER_MAP","blur","brightness","contrast","grayscale","hueRotate","invert","opacityFilter","saturate","sepia","FILTER_PROPERTIES","getElementTop","el","top","element","offsetTop","offsetParent","getUnit","property","propertyUnit","getValueInPx","maxScroll","_a","floatValue","parseFloat","match","vh","window","innerHeight","valueInPx","convertPropToPixels","propName","propValue","offset","propValueInPx","isElement","HTMLElement","keyCodes","ZERO","NINE","test","charCodeAt","document","querySelector","console","warn","offsetHeight","offsetInPx","hexToObject","hex","color","result","exec","r","parseInt","g","b","a","rgbToObject","rgb","isRgba","toLowerCase","replace","parallax","scrollPosition","start","duration","startValue","endValue","easing","min","max","percentage","Array","isArray","Math","floor","colorParallax","startObject","endObject","round","applyPropertyToStyle","propertyData","startPosition","style","transforms","filters","isColor","parallaxMethod","transformMethod","filterMethod","newStyle","getClasses","lastSegmentScrolledBy","isInSegment","parallaxData","cssClasses","segmentName","name","nextSegmentName","checkIsActive","classes","updateDOM","props","showElement","propsUsedInParallax","plxStyleRef","plxStateClassesRef","elementRef","animateWhenNotInViewport","disabled","freeze","className","onPlxEnd","onPlxStart","plxStyle","current","plxStateClasses","rect","getBoundingClientRect","isTopAboveBottomEdge","isBottomBelowTopEdge","height","appliedProperties","segments","bodyHeight","documentElement","scrollHeight","body","endOffset","properties","startOffset","end","startInPx","durationInPx","endInPx","isScrolledByStart","forEach","push","data","transformsOrdered","transformKey","transform","join","webkitTransform","filtersArray","filterKey","filter","webkitFilter","JSON","stringify","requestAnimationFrame","newPlxStateClasses","newClassName","wasActive","isActive","Plx","children","divProps","scrollManager","resizeTimeout","plxStyleClasses","setShowElement","segment","includes","willChange","map","str","letter","update","currentScrollPosition","getScrollPosition","scrollPositionY","handleResize","clearTimeout","setTimeout","handleScrollChange","detail","addEventListener","removeEventListener","removeListener","elementStyle","assign","visibility","undefined","createElement","ref"],"mappings":"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","sourcesContent":["var __rest = (this && this.__rest) || function (s, e) {\n    var t = {};\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\n        t[p] = s[p];\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\n                t[p[i]] = s[p[i]];\n        }\n    return t;\n};\nimport React, { useCallback, useEffect, useMemo, useRef, useState, } from \"react\";\nimport BezierEasing from \"bezier-easing\";\n// @ts-ignore\nimport ScrollManager from \"window-scroll-manager\";\n// ------------ Constants\n// Regex that checks for numbers in string\n// formatted as \"{number}{unit}\" where unit is \"px\", \"vh\", \"%\" or none\nconst START_END_DURATION_REGEX = /^-?\\d+(\\.\\d+)?(px|vh|%)?$/;\nconst DEFAULT_UNIT = \"px\";\nconst DEFAULT_ANGLE_UNIT = \"deg\";\nconst ANGLE_PROPERTIES = [\"rotate\", \"rotateX\", \"rotateY\", \"rotateZ\", \"skew\", \"skewX\", \"skewY\", \"skewZ\", \"hueRotate\"];\nconst EASINGS = {\n    ease: [0.25, 0.1, 0.25, 1.0],\n    easeIn: [0.42, 0.0, 1.0, 1.0],\n    easeOut: [0.0, 0.0, 0.58, 1.0],\n    easeInOut: [0.42, 0.0, 0.58, 1.0],\n    easeInSine: [0.47, 0, 0.745, 0.715],\n    easeOutSine: [0.39, 0.575, 0.565, 1],\n    easeInOutSine: [0.445, 0.05, 0.55, 0.95],\n    easeInQuad: [0.55, 0.085, 0.68, 0.53],\n    easeOutQuad: [0.25, 0.46, 0.45, 0.94],\n    easeInOutQuad: [0.455, 0.03, 0.515, 0.955],\n    easeInCubic: [0.55, 0.055, 0.675, 0.19],\n    easeOutCubic: [0.215, 0.61, 0.355, 1],\n    easeInOutCubic: [0.645, 0.045, 0.355, 1],\n    easeInQuart: [0.895, 0.03, 0.685, 0.22],\n    easeOutQuart: [0.165, 0.84, 0.44, 1],\n    easeInOutQuart: [0.77, 0, 0.175, 1],\n    easeInQuint: [0.755, 0.05, 0.855, 0.06],\n    easeOutQuint: [0.23, 1, 0.32, 1],\n    easeInOutQuint: [0.86, 0, 0.07, 1],\n    easeInExpo: [0.95, 0.05, 0.795, 0.035],\n    easeOutExpo: [0.19, 1, 0.22, 1],\n    easeInOutExpo: [1, 0, 0, 1],\n    easeInCirc: [0.6, 0.04, 0.98, 0.335],\n    easeOutCirc: [0.075, 0.82, 0.165, 1],\n    easeInOutCirc: [0.785, 0.135, 0.15, 0.86],\n};\n// Color regex\n// 0 - 199 | 200 - 249 | 250 - 255\nconst REGEX_0_255 = \"(1?[0-9]?[0-9]|2[0-4][0-9]|25[0-5])\";\n// 0.0 - 1.9999...\nconst REGEX_0_1 = \"([01](\\\\.\\\\d+)?)\";\n// 00 - FF\nconst REGEX_TWO_HEX_DIGITS = \"([a-f\\\\d]{2})\";\nconst HEX_REGEX = new RegExp(`^#${REGEX_TWO_HEX_DIGITS}${REGEX_TWO_HEX_DIGITS}${REGEX_TWO_HEX_DIGITS}$`, \"i\");\nconst RGB_REGEX = new RegExp(`^rgb\\\\(${REGEX_0_255},${REGEX_0_255},${REGEX_0_255}\\\\)$`, \"i\");\nconst RGBA_REGEX = new RegExp(`^rgba\\\\(${REGEX_0_255},${REGEX_0_255},${REGEX_0_255},${REGEX_0_1}\\\\)$`, \"i\");\nconst SCROLL_OFFSET = 50;\nconst RESIZE_DEBOUNCE_TIMEOUT = 150;\n// CSS transform map\nconst TRANSFORM_MAP = {\n    rotate: (value, unit = DEFAULT_ANGLE_UNIT) => `rotate(${value}${unit})`,\n    rotateX: (value, unit = DEFAULT_ANGLE_UNIT) => `rotateX(${value}${unit})`,\n    rotateY: (value, unit = DEFAULT_ANGLE_UNIT) => `rotateY(${value}${unit})`,\n    rotateZ: (value, unit = DEFAULT_ANGLE_UNIT) => `rotateZ(${value}${unit})`,\n    scale: (value) => `scale(${value})`,\n    scaleX: (value) => `scaleX(${value})`,\n    scaleY: (value) => `scaleY(${value})`,\n    scaleZ: (value) => `scaleZ(${value})`,\n    skew: (value, unit = DEFAULT_UNIT) => `skew(${value}${unit})`,\n    skewX: (value, unit = DEFAULT_UNIT) => `skewX(${value}${unit})`,\n    skewY: (value, unit = DEFAULT_UNIT) => `skewY(${value}${unit})`,\n    skewZ: (value, unit = DEFAULT_UNIT) => `skewZ(${value}${unit})`,\n    translateX: (value, unit = DEFAULT_UNIT) => `translateX(${value}${unit})`,\n    translateY: (value, unit = DEFAULT_UNIT) => `translateY(${value}${unit})`,\n    translateZ: (value, unit = DEFAULT_UNIT) => `translateZ(${value}${unit})`,\n};\n// Order of CSS transforms matters\nconst ORDER_OF_TRANSFORMS = [\n    \"translateX\",\n    \"translateY\",\n    \"translateZ\",\n    \"skew\",\n    \"skewX\",\n    \"skewY\",\n    \"skewZ\",\n    \"rotate\",\n    \"rotateX\",\n    \"rotateY\",\n    \"rotateZ\",\n    \"scale\",\n    \"scaleX\",\n    \"scaleY\",\n    \"scaleZ\",\n];\n// CSS properties that use color values\nconst COLOR_PROPERTIES = [\n    \"backgroundColor\",\n    \"borderBottomColor\",\n    \"borderColor\",\n    \"borderLeftColor\",\n    \"borderRightColor\",\n    \"borderTopColor\",\n    \"color\",\n    \"fill\",\n    \"stroke\",\n];\n// CSS filter map\n// blur()\n// brightness()\n// contrast()\n// grayscale()\n// hue-rotate()\n// invert()\n// opacity() // use opacityFilter\n// saturate()\n// sepia()\n// Not supported\n// drop-shadow()\n// url()\nconst FILTER_MAP = {\n    blur: (value, unit = DEFAULT_UNIT) => `blur(${value}${unit})`,\n    brightness: (value) => `brightness(${value})`,\n    contrast: (value) => `contrast(${value})`,\n    grayscale: (value) => `grayscale(${value})`,\n    hueRotate: (value, unit = DEFAULT_ANGLE_UNIT) => `hue-rotate(${value}${unit})`,\n    invert: (value) => `invert(${value})`,\n    opacityFilter: (value) => `opacity(${value})`,\n    saturate: (value) => `saturate(${value})`,\n    sepia: (value) => `sepia(${value})`,\n};\nconst FILTER_PROPERTIES = [\n    \"blur\",\n    \"brightness\",\n    \"contrast\",\n    \"grayscale\",\n    \"hueRotate\",\n    \"invert\",\n    \"opacityFilter\",\n    \"saturate\",\n    \"sepia\",\n];\n// ------------ Helpers\n// Get element's top offset\nfunction getElementTop(el) {\n    let top = 0;\n    let element = el;\n    do {\n        top += element.offsetTop || 0;\n        element = element.offsetParent;\n    } while (element);\n    return top;\n}\n// Returns CSS unit\nfunction getUnit(property, unit) {\n    let propertyUnit = unit || DEFAULT_UNIT;\n    if (ANGLE_PROPERTIES.indexOf(property) >= 0) {\n        propertyUnit = unit || DEFAULT_ANGLE_UNIT;\n    }\n    return propertyUnit;\n}\n// Takes string value (in px/vh/%) and returns number\nfunction getValueInPx(value, maxScroll) {\n    var _a;\n    const floatValue = parseFloat(value);\n    const unit = ((_a = value.match(START_END_DURATION_REGEX)) === null || _a === void 0 ? void 0 : _a[2]) || null;\n    const vh = window.innerHeight / 100;\n    let valueInPx;\n    switch (unit) {\n        case \"vh\":\n            valueInPx = vh * floatValue;\n            break;\n        case \"%\":\n            valueInPx = (maxScroll * floatValue) / 100;\n            break;\n        default:\n            valueInPx = floatValue;\n    }\n    return valueInPx;\n}\n// Takes start/end/duration props\n// and return number (in pixels) based on prop type (number, string, dom element)\nfunction convertPropToPixels(propName, propValue, maxScroll, offset = 0) {\n    let propValueInPx = propValue;\n    const isElement = propValue instanceof HTMLElement;\n    const keyCodes = {\n        ZERO: 48,\n        NINE: 57,\n    };\n    if (typeof propValue === \"number\") {\n        propValueInPx = propValue;\n    }\n    else if (START_END_DURATION_REGEX.test(propValue)) {\n        propValueInPx = getValueInPx(propValue, maxScroll);\n    }\n    else if (isElement ||\n        (typeof propValue === \"string\" &&\n            (propValue.charCodeAt(0) < keyCodes.ZERO || propValue.charCodeAt(0) > keyCodes.NINE))) {\n        const element = isElement ? propValue : document.querySelector(propValue);\n        if (!element) {\n            console.warn(`Plx, ERROR: ${propName} selector matches no elements: \"${propValue}\"`);\n            return null;\n        }\n        if (propName === \"start\" || propName === \"end\") {\n            // START or END\n            // Element enters the viewport\n            propValueInPx = getElementTop(element) - window.innerHeight;\n        }\n        else if (propName === \"duration\") {\n            // DURATION\n            // Height of the element\n            propValueInPx = element.offsetHeight;\n        }\n    }\n    else {\n        console.warn(`Plx, ERROR: \"${propValue}\" is not a valid ${propName} value, check documentation`);\n        return null;\n    }\n    // Transform offset to px\n    let offsetInPx = 0;\n    if (typeof offset === \"number\") {\n        offsetInPx = offset;\n    }\n    else if (START_END_DURATION_REGEX.test(offset)) {\n        offsetInPx = getValueInPx(offset, maxScroll);\n    }\n    // Add offset\n    propValueInPx += offsetInPx;\n    if (propValueInPx < 0) {\n        propValueInPx = 0;\n    }\n    return propValueInPx;\n}\n// Converts color in hex format into object { r, g, b, a }\nfunction hexToObject(hex) {\n    // Convert #abc to #aabbcc\n    const color = hex.length === 4 ? `#${hex[1]}${hex[1]}${hex[2]}${hex[2]}${hex[3]}${hex[3]}` : hex;\n    const result = HEX_REGEX.exec(color);\n    // Safety check, if color is in the wrong format\n    if (!result) {\n        console.warn(`Plx, ERROR: hex color is not in the right format: \"${hex}\"`);\n        return null;\n    }\n    // All color functions are returning { r, g, b, a } object\n    return {\n        r: parseInt(result[1], 16),\n        g: parseInt(result[2], 16),\n        b: parseInt(result[3], 16),\n        a: 1,\n    };\n}\n// Converts color in rgb format into object { r, g, b, a }\nfunction rgbToObject(rgb) {\n    const isRgba = rgb.toLowerCase().indexOf(\"rgba\") === 0;\n    const color = rgb.replace(/ /g, \"\");\n    const result = isRgba ? RGBA_REGEX.exec(color) : RGB_REGEX.exec(color);\n    // Safety check, if color is in the wrong format\n    if (!result) {\n        console.warn(`Plx, ERROR: rgb or rgba color is not in the right format: \"${rgb}\"`);\n        return null;\n    }\n    // All color functions are returning { r, g, b, a } object\n    return {\n        r: parseInt(result[1], 10),\n        g: parseInt(result[2], 10),\n        b: parseInt(result[3], 10),\n        a: isRgba ? parseFloat(result[4]) : 1,\n    };\n}\n// Calculates the current value for parallax-ing property\nfunction parallax(scrollPosition, start, duration, startValue, endValue, easing) {\n    // Safety check, if \"startValue\" is in the wrong format\n    if (typeof startValue !== \"number\") {\n        console.warn(`Plx, ERROR: startValue is not a number (type: \"${typeof endValue}\", value: \"${endValue}\")`);\n        return 0;\n    }\n    // Safety check, if \"endValue\" is in the wrong format\n    if (typeof endValue !== \"number\") {\n        console.warn(`Plx, ERROR: endValue is not a number (type: \"${typeof endValue}\", value: \"${endValue}\")`);\n        return 0;\n    }\n    // Safety check, if \"duration\" is in the wrong format\n    if (typeof duration !== \"number\" || duration === 0) {\n        console.warn(`Plx, ERROR: duration is zero or not a number (type: \"${typeof duration}\", value: \"${duration}\")`);\n        return 0;\n    }\n    let min = startValue;\n    let max = endValue;\n    const invert = startValue > endValue;\n    if (invert) {\n        min = endValue;\n        max = startValue;\n    }\n    let percentage = (scrollPosition - start) / duration;\n    if (percentage > 1) {\n        percentage = 1;\n    }\n    else if (percentage < 0) {\n        percentage = 0;\n    }\n    // Apply easing\n    if (easing) {\n        if (Array.isArray(easing)) {\n            percentage = BezierEasing(easing[0], easing[1], easing[2], easing[3])(percentage);\n        }\n        else if (typeof easing === \"string\" && EASINGS[easing]) {\n            percentage = BezierEasing(EASINGS[easing][0], EASINGS[easing][1], EASINGS[easing][2], EASINGS[easing][3])(percentage);\n        }\n        else if (typeof easing === \"function\") {\n            percentage = easing(percentage);\n        }\n    }\n    let value = percentage * (max - min);\n    if (invert) {\n        value = max - value;\n    }\n    else {\n        value += min;\n    }\n    // Rounding to 4 decimals (.toFixed(4) returns a string)\n    return Math.floor(value * 10000) / 10000;\n}\n// Calculates current value for color parallax\nfunction colorParallax(scrollPosition, start, duration, startValue, endValue, easing) {\n    let startObject = null;\n    let endObject = null;\n    if (typeof startValue === \"string\") {\n        if (startValue[0].toLowerCase() === \"r\") {\n            startObject = rgbToObject(startValue);\n        }\n        else {\n            startObject = hexToObject(startValue);\n        }\n    }\n    if (typeof endValue === \"string\") {\n        if (endValue[0].toLowerCase() === \"r\") {\n            endObject = rgbToObject(endValue);\n        }\n        else {\n            endObject = hexToObject(endValue);\n        }\n    }\n    if (startObject && endObject) {\n        const r = parallax(scrollPosition, start, duration, startObject.r, endObject.r, easing);\n        const g = parallax(scrollPosition, start, duration, startObject.g, endObject.g, easing);\n        const b = parallax(scrollPosition, start, duration, startObject.b, endObject.b, easing);\n        const a = parallax(scrollPosition, start, duration, startObject.a, endObject.a, easing);\n        return `rgba(${Math.round(r)}, ${Math.round(g)}, ${Math.round(b)}, ${a})`;\n    }\n    return \"\";\n}\n// Applies property parallax to the style object\nfunction applyPropertyToStyle(scrollPosition, propertyData, startPosition, duration, style, transforms, filters, easing) {\n    const { startValue, endValue, property, unit } = propertyData;\n    // If property is one of the color properties\n    // Use it's parallax method\n    const isColor = COLOR_PROPERTIES.indexOf(property) > -1;\n    const parallaxMethod = isColor ? colorParallax : parallax;\n    // Get new CSS value\n    const value = parallaxMethod(scrollPosition, startPosition, duration, startValue, endValue, easing);\n    // Get transform function\n    const transformMethod = TRANSFORM_MAP[property];\n    const filterMethod = FILTER_MAP[property];\n    const newStyle = style;\n    if (transformMethod) {\n        // Get CSS unit\n        const propertyUnit = getUnit(property, unit);\n        // Transforms, apply value to transform function\n        transforms[property] = transformMethod(value, propertyUnit);\n    }\n    else if (filterMethod) {\n        // Get CSS unit\n        const propertyUnit = getUnit(property, unit);\n        // Filters, apply value to filter function\n        filters[property] = filterMethod(value, propertyUnit);\n    }\n    else {\n        // All other properties\n        newStyle[property] = value;\n        // Add unit if it is passed\n        if (unit) {\n            newStyle[property] += unit;\n        }\n    }\n}\n// Returns CSS classes based on animation state\nfunction getClasses(lastSegmentScrolledBy, isInSegment, parallaxData) {\n    let cssClasses = \"\";\n    if (lastSegmentScrolledBy === null) {\n        cssClasses = \"Plx--above\";\n    }\n    else if (lastSegmentScrolledBy === parallaxData.length - 1 && !isInSegment) {\n        cssClasses = \"Plx--below\";\n    }\n    else if (lastSegmentScrolledBy !== null && isInSegment) {\n        const segmentName = parallaxData[lastSegmentScrolledBy].name || lastSegmentScrolledBy;\n        cssClasses = `Plx--active Plx--in Plx--in-${segmentName}`;\n    }\n    else if (lastSegmentScrolledBy !== null && !isInSegment) {\n        const segmentName = parallaxData[lastSegmentScrolledBy].name || lastSegmentScrolledBy;\n        const nextSegmentName = parallaxData[lastSegmentScrolledBy + 1].name || lastSegmentScrolledBy + 1;\n        cssClasses = `Plx--active Plx--between Plx--between-${segmentName}-and-${nextSegmentName}`;\n    }\n    return cssClasses;\n}\n// Checks if class contains 'active'\nfunction checkIsActive(classes) {\n    return classes.indexOf(\"Plx--active\") > -1;\n}\n// Main update function\n// Returns new state object based on props and scroll position\nfunction updateDOM(scrollPosition, props, showElement, propsUsedInParallax, plxStyleRef, plxStateClassesRef, elementRef) {\n    const { animateWhenNotInViewport, disabled, freeze, parallaxData, className, onPlxEnd, onPlxStart, style } = props;\n    const plxStyle = plxStyleRef.current;\n    const plxStateClasses = plxStateClassesRef.current;\n    const element = elementRef.current;\n    // Do nothing if animation is disabled, frozen\n    // or if element is not rendered yet\n    if ((freeze && showElement) || !element || disabled) {\n        return;\n    }\n    // Check if element is in viewport\n    // Small offset is added to prevent page jumping\n    if (!animateWhenNotInViewport) {\n        const rect = element.getBoundingClientRect();\n        const isTopAboveBottomEdge = rect.top < window.innerHeight + SCROLL_OFFSET;\n        const isBottomBelowTopEdge = rect.top + rect.height > -SCROLL_OFFSET;\n        if (!isTopAboveBottomEdge || !isBottomBelowTopEdge) {\n            return;\n        }\n    }\n    // Style to be applied to our element\n    let newStyle = {};\n    const transforms = {};\n    const filters = {};\n    const appliedProperties = [];\n    const segments = [];\n    let isInSegment = false;\n    let lastSegmentScrolledBy = null;\n    const bodyHeight = document.documentElement.scrollHeight || document.body.scrollHeight;\n    const maxScroll = bodyHeight - window.innerHeight;\n    for (let i = 0; i < parallaxData.length; i++) {\n        const { duration, easing, endOffset, properties, startOffset } = parallaxData[i];\n        const start = parallaxData[i].start === \"self\" ? element : parallaxData[i].start;\n        const end = parallaxData[i].end === \"self\" ? element : parallaxData[i].end;\n        const startInPx = convertPropToPixels(\"start\", start, maxScroll, startOffset);\n        let durationInPx;\n        let endInPx;\n        // End has higher priority than duration\n        if (typeof end !== \"undefined\") {\n            endInPx = convertPropToPixels(\"end\", end, maxScroll, endOffset);\n            durationInPx = endInPx - startInPx;\n        }\n        else {\n            durationInPx = convertPropToPixels(\"duration\", duration, maxScroll);\n            endInPx = startInPx + durationInPx;\n        }\n        // If segment is below scroll position skip it\n        if (scrollPosition < startInPx) {\n            break;\n        }\n        const isScrolledByStart = scrollPosition >= startInPx;\n        if (isScrolledByStart) {\n            lastSegmentScrolledBy = i;\n        }\n        // If active segment exists, apply his properties\n        if (scrollPosition >= startInPx && scrollPosition <= endInPx) {\n            isInSegment = true;\n            properties.forEach((propertyData) => {\n                const { property } = propertyData;\n                // Save which properties are applied to the active segment\n                // So they are not re-applied for other segments\n                appliedProperties.push(property);\n                // Apply property style\n                applyPropertyToStyle(scrollPosition, propertyData, startInPx, durationInPx, newStyle, transforms, filters, easing);\n            });\n        }\n        else {\n            // Push non active segments above the scroll position to separate array\n            // This way \"durationInPx\" and \"startInPx\" are not calculated again\n            // and segments below scroll position are skipped in the next step\n            segments.push({\n                easing,\n                durationInPx,\n                properties,\n                startInPx,\n            });\n        }\n    }\n    // These are only segments that are completely above scroll position\n    segments.forEach((data) => {\n        const { easing, durationInPx, properties, startInPx } = data;\n        properties.forEach((propertyData) => {\n            const { property } = propertyData;\n            // Skip property that was changed for active segment\n            if (appliedProperties.indexOf(property) > -1) {\n                return;\n            }\n            // These styles that are the ones changed by segments\n            // that are above active segment\n            applyPropertyToStyle(scrollPosition, propertyData, startInPx, durationInPx, newStyle, transforms, filters, easing);\n        });\n    });\n    // Sort transforms by ORDER_OF_TRANSFORMS\n    // as order of CSS transforms matters\n    const transformsOrdered = [];\n    ORDER_OF_TRANSFORMS.forEach((transformKey) => {\n        if (transforms[transformKey]) {\n            transformsOrdered.push(transforms[transformKey]);\n        }\n    });\n    // Concat transforms and add webkit prefix\n    newStyle.transform = transformsOrdered.join(\" \");\n    newStyle.webkitTransform = newStyle.transform;\n    const filtersArray = [];\n    FILTER_PROPERTIES.forEach((filterKey) => {\n        if (filters[filterKey]) {\n            filtersArray.push(filters[filterKey]);\n        }\n    });\n    // Concat filters and add webkit prefix\n    newStyle.filter = filtersArray.join(\" \");\n    newStyle.webkitFilter = newStyle.filter;\n    // \"Stupid\" check if style should be updated\n    if (JSON.stringify(plxStyle) !== JSON.stringify(newStyle)) {\n        // Set styles\n        requestAnimationFrame(() => {\n            // Add user styles\n            for (const property in style) {\n                // @ts-ignore\n                element.style[property] = style[property];\n            }\n            // Add parallax styles\n            propsUsedInParallax.forEach((property) => {\n                // @ts-ignore\n                element.style[property] = typeof newStyle[property] === \"undefined\" ? \"\" : newStyle[property];\n            });\n        });\n        plxStyleRef.current = newStyle;\n    }\n    // Adding state classes\n    const newPlxStateClasses = getClasses(lastSegmentScrolledBy, isInSegment, parallaxData);\n    if (newPlxStateClasses !== plxStateClasses) {\n        const newClassName = `${className} Plx ${newPlxStateClasses}`;\n        if (newClassName !== element.className) {\n            const wasActive = checkIsActive(element.className);\n            const isActive = checkIsActive(newClassName);\n            element.className = newClassName;\n            // Callbacks\n            if (!wasActive && isActive) {\n                onPlxStart === null || onPlxStart === void 0 ? void 0 : onPlxStart();\n            }\n            else if (wasActive && !isActive) {\n                onPlxEnd === null || onPlxEnd === void 0 ? void 0 : onPlxEnd();\n            }\n        }\n        // Cache plx classes\n        plxStateClassesRef.current = newPlxStateClasses;\n    }\n}\nconst Plx = (props) => {\n    const { animateWhenNotInViewport = false, children, className = \"\", disabled = false, freeze = false, parallaxData, style = {}, onPlxStart, onPlxEnd } = props, divProps = __rest(props, [\"animateWhenNotInViewport\", \"children\", \"className\", \"disabled\", \"freeze\", \"parallaxData\", \"style\", \"onPlxStart\", \"onPlxEnd\"]);\n    const scrollManager = useRef();\n    const resizeTimeout = useRef();\n    const element = useRef(null);\n    const plxStyle = useRef({});\n    const plxStyleClasses = useRef(\"\");\n    const [showElement, setShowElement] = useState(false);\n    // Get properties that are used in a parallax effect\n    const propsUsedInParallax = useMemo(() => {\n        const properties = [];\n        parallaxData.forEach((segment) => {\n            segment.properties.forEach(({ property }) => {\n                const transformMethod = TRANSFORM_MAP[property];\n                const filterMethod = FILTER_MAP[property];\n                if (transformMethod) {\n                    if (!properties.includes(\"transform\")) {\n                        properties.push(\"transform\", \"webkitTransform\");\n                    }\n                }\n                else if (filterMethod) {\n                    if (!properties.includes(\"filter\")) {\n                        properties.push(\"filter\", \"webkitFilter\");\n                    }\n                }\n                else {\n                    if (!properties.includes(property)) {\n                        properties.push(property);\n                    }\n                }\n            });\n        });\n        return properties;\n    }, [parallaxData]);\n    // Set will-change property\n    useEffect(() => {\n        if (element.current) {\n            element.current.style.willChange = propsUsedInParallax\n                .map((str) => {\n                return str.replace(/[A-Z]/g, (letter) => `-${letter.toLowerCase()}`).replace(\"webkit\", \"-webkit\");\n            })\n                .join(\",\");\n        }\n    }, [element, propsUsedInParallax]);\n    const update = useCallback((scrollPosition = null) => {\n        const currentScrollPosition = scrollPosition === null ? scrollManager.current.getScrollPosition().scrollPositionY : scrollPosition;\n        updateDOM(currentScrollPosition, props, showElement, propsUsedInParallax, plxStyle, plxStyleClasses, element);\n    }, [props]);\n    // Window resize\n    const handleResize = useCallback(() => {\n        clearTimeout(resizeTimeout.current);\n        resizeTimeout.current = setTimeout(() => {\n            update();\n        }, RESIZE_DEBOUNCE_TIMEOUT);\n    }, [props]);\n    useEffect(() => {\n        if (scrollManager.current) {\n            if (disabled) {\n                // When disabled leave only user styles\n                propsUsedInParallax.forEach((property) => {\n                    if (element.current) {\n                        // @ts-ignore\n                        element.current.style[property] = \"\";\n                    }\n                });\n            }\n            else {\n                update();\n            }\n        }\n    }, [disabled]);\n    // Window scroll\n    const handleScrollChange = useCallback((e) => {\n        update(e.detail.scrollPositionY);\n    }, [props]);\n    useEffect(() => {\n        // Get scroll manager singleton\n        scrollManager.current = new ScrollManager();\n        // Add listeners\n        window.addEventListener(\"window-scroll\", handleScrollChange);\n        window.addEventListener(\"resize\", handleResize);\n        update();\n        setShowElement(true);\n        return () => {\n            clearTimeout(resizeTimeout.current);\n            window.removeEventListener(\"window-scroll\", handleScrollChange);\n            window.removeEventListener(\"resize\", handleResize);\n            scrollManager.current.removeListener();\n        };\n    }, [props]);\n    // Update DOM on props change\n    useEffect(() => {\n        update();\n    }, []);\n    let elementStyle = style;\n    if (!disabled) {\n        elementStyle = Object.assign(Object.assign({}, style), { \n            // Hide element before until it is rendered\n            // This prevents jumps if page is scrolled and then refreshed\n            visibility: showElement ? undefined : \"hidden\" });\n    }\n    return (React.createElement(\"div\", Object.assign({}, divProps, { className: `${className} Plx`, style: elementStyle, ref: element }), children));\n};\nexport default Plx;\n"]},"metadata":{},"sourceType":"module"}